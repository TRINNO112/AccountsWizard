<!-- save as galaxy-demo.html and open in browser -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galactic Hover Visual - Prototype</title>
<style>
  :root{
    --bg:#06021a;
    --accent1:#00ffd6;
    --accent2:#ff3ecf;
    --accent3:#7afcff;
  }
  html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;font-family:sans-serif}
  #canvas{position:fixed;inset:0;display:block;z-index:1}
  /* floating UI icons */
  .icon {
    position:absolute;
    z-index:5;
    width:72px; height:72px;
    display:flex;align-items:center;justify-content:center;
    border-radius:12px;
    background:linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    box-shadow: 0 6px 30px rgba(0,0,0,0.6), 0 0 18px rgba(0,0,0,0.2) inset;
    border:1px solid rgba(255,255,255,0.03);
    color:white;
    pointer-events:auto;
    user-select:none;
    transition:transform .28s cubic-bezier(.2,.9,.2,1), box-shadow .28s;
  }
  .icon .dot {
    width:22px;height:22px;border-radius:50%;
    background: radial-gradient(circle at 30% 30%, var(--accent1), var(--accent2));
    box-shadow:0 0 16px rgba(0,255,214,0.35), 0 0 34px rgba(255,62,207,0.12);
    transform: translateZ(0);
  }
  .icon:hover { transform: scale(1.08) translateY(-6px); box-shadow: 0 18px 60px rgba(0,0,0,0.6); }
  /* control panel */
  .controls {
    position:fixed; right:18px; top:18px; z-index:10; color:#cbd5e1;
    font-size:13px; background:rgba(255,255,255,0.02); padding:10px 12px; border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
    backdrop-filter: blur(6px);
  }
  .btn { display:inline-block; padding:6px 10px; border-radius:8px; background:rgba(255,255,255,0.02); color:#dbeafe; border:1px solid rgba(255,255,255,0.02); cursor:pointer; }
  .hint { position:fixed; left:18px; bottom:18px; color:#a0aec0; z-index:10; font-size:13px; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- floating icons -->
<div class="icon" data-ix="icon" style="left:12%; top:22%;">
  <div class="dot"></div>
</div>
<div class="icon" data-ix="icon" style="left:52%; top:14%;">
  <div class="dot"></div>
</div>
<div class="icon" data-ix="icon" style="left:78%; top:60%;">
  <div class="dot"></div>
</div>
<div class="icon" data-ix="icon" style="left:28%; top:72%;">
  <div class="dot"></div>
</div>

<div class="controls" aria-hidden="true">
  <div><strong>Galactic Decor — Prototype</strong></div>
  <div style="margin-top:8px">
    <button id="toggleMotion" class="btn">Pause</button>
    <button id="spawnBurst" class="btn">Burst</button>
  </div>
</div>

<div class="hint" aria-hidden="true">Hover or move mouse — hover icons for burst effect</div>

<script>
/* ================ GALAXY PARTICLES PROTOTYPE ================ */
/* Lightweight canvas particle system with singularity attraction
   - Move mouse = attract particles (soft)
   - Hover icon = local burst / blackhole-eject effect
*/

(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {alpha:true});
  let W = innerWidth, H = innerHeight;
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = W * DPR; canvas.height = H * DPR;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.scale(DPR, DPR);

  // Config
  const MAX_PARTICLES = Math.min(220, Math.round((W*H)/30000));
  const PARTICLE_COLORS = ['rgba(0,255,214,0.08)','rgba(124,255,255,0.06)','rgba(255,62,207,0.06)'];
  const particles = [];
  const icons = Array.from(document.querySelectorAll('[data-ix="icon"]'));
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  let paused = false;

  // utilities
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Particle class
  class Particle {
    constructor(){
      this.reset(true);
    }
    reset(init=false){
      this.x = rand(0,W); this.y = rand(0,H);
      const angle = rand(0, Math.PI*2);
      const speed = rand(0.02, 0.6);
      this.vx = Math.cos(angle)*speed;
      this.vy = Math.sin(angle)*speed;
      this.size = rand(1.2, 6) * (DPR>1?1:1);
      this.baseSize = this.size;
      this.color = PARTICLE_COLORS[Math.floor(Math.random()*PARTICLE_COLORS.length)];
      this.alpha = rand(0.06, 0.25);
      this.layer = init? Math.random():Math.random();
      this.ttl = 99999;
    }
    update(forces, dt){
      // apply force vector (fx,fy)
      if(forces && (forces.fx || forces.fy)){
        this.vx += forces.fx * dt;
        this.vy += forces.fy * dt;
      }
      // slight drift
      // dampening
      this.vx *= 0.995; this.vy *= 0.995;
      // clamp velocity
      const vmag = Math.hypot(this.vx,this.vy);
      const vmax = 2.6;
      if(vmag > vmax){
        this.vx = (this.vx/vmag) * vmax;
        this.vy = (this.vy/vmag) * vmax;
      }
      this.x += this.vx * dt * 16;
      this.y += this.vy * dt * 16;
      // wrap
      if(this.x < -20) this.x = W+20;
      if(this.x > W+20) this.x = -20;
      if(this.y < -20) this.y = H+20;
      if(this.y > H+20) this.y = -20;
    }
    draw(ctx){
      ctx.beginPath();
      const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size*6);
      g.addColorStop(0, this.color.replace(/0\.0*\)/,'0.4)'));
      g.addColorStop(0.6, this.color.replace(/0\.0*\)/,'0.06)'));
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(this.x - this.size*6, this.y - this.size*6, this.size*12, this.size*12);
    }
  }

  // init particles
  for(let i=0;i<MAX_PARTICLES;i++) particles.push(new Particle());

  // singularity (cursor)
  let mouse = {x:W/2, y:H/2, active:false};
  let last = performance.now();
  function frame(now){
    if(paused || prefersReduced) {
      // draw a still subtle background if paused
      ctx.clearRect(0,0,W,H);
      drawStars();
      requestAnimationFrame(frame);
      return;
    }
    const dt = Math.min(1, (now-last)/16);
    last = now;

    ctx.clearRect(0,0,W,H);

    // subtle background stars layer
    drawStars();

    // If mouse active => attraction force applied to particles
    const sing = mouse.active ? {x:mouse.x, y:mouse.y, strength: (mouse.push? -1.6 : 0.8) } : null;

    // update & draw particles
    particles.forEach(p => {
      let fx = 0, fy = 0;
      if(sing){
        const dx = sing.x - p.x, dy = sing.y - p.y;
        const d2 = dx*dx + dy*dy + 0.001;
        const d = Math.sqrt(d2);
        // Force magnitude: direction * k/(d^power) ; power slightly >1 for nicer feel
        const power = 1.3;
        const k = sing.strength * 220; // tweakable strength
        const mag = k / Math.pow(d, power);
        fx = (dx/d) * mag;
        fy = (dy/d) * mag;
        // near singularity add glow / size
        const near = d < 90;
        if(near) p.size = lerp(p.size, p.baseSize*1.8, 0.12);
        else p.size = lerp(p.size, p.baseSize, 0.05);
      } else {
        p.size = lerp(p.size, p.baseSize, 0.02);
      }
      p.update({fx,fy}, dt);
      p.draw(ctx);
    });

    requestAnimationFrame(frame);
  }

  // background stars: draw once per frame for subtle movement
  const starCount = Math.round(80 * Math.min(1, W/1200));
  const starPoints = new Array(starCount).fill(0).map(()=>{
    return {x:rand(0,W), y:rand(0,H), r:rand(0.3,1.4), a:rand(0.02,0.12)};
  });
  function drawStars(){
    // subtle gradient overlay
    const bgGrad = ctx.createLinearGradient(0,0,0,H);
    bgGrad.addColorStop(0, 'rgba(10,6,20,0.9)');
    bgGrad.addColorStop(1, 'rgba(4,2,12,0.9)');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0,0,W,H);

    starPoints.forEach(s=>{
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${s.a})`;
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // mouse events
  window.addEventListener('mousemove', e=>{
    mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; mouse.push = false;
  });
  window.addEventListener('mouseleave', e=>{
    mouse.active = false;
  });
  window.addEventListener('mousedown', e=>{
    // strong singularity (pull then push)
    mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; mouse.push = true;
    setTimeout(()=> mouse.push = false, 140);
  });

  // Icon hover burst: push particles away from icon center
  icons.forEach(icon=>{
    icon.addEventListener('mouseenter', (ev)=>{
      const rect = icon.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      // small attraction then burst
      triggerBurst(cx,cy);
    });
    // optional: click for bigger burst
    icon.addEventListener('click', (ev)=>{
      const rect = icon.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      triggerBurst(cx,cy, true);
    });
  });

  function triggerBurst(x,y,big=false){
    // temporary pull (simulate black hole) then big outward impulse
    // step 1: pull (set local mouse attraction)
    mouse.x = x; mouse.y = y; mouse.active = true; mouse.push = false;
    // after short delay, push particles outward strongly
    setTimeout(()=>{
      const strength = big ? 900 : 540;
      // apply instant impulse to nearby particles
      particles.forEach(p=>{
        const dx = p.x - x, dy = p.y - y;
        const d = Math.hypot(dx,dy) + 0.0001;
        // only affect near particles
        if(d < 260){
          const force = (1 - (d/260)) * strength;
          p.vx += (dx/d) * force * 0.002 * (big?1.6:1);
          p.vy += (dy/d) * force * 0.002 * (big?1.6:1);
        }
      });
      // end local attract
      mouse.active = false;
    }, 180);
  }

  // controls
  document.getElementById('toggleMotion').addEventListener('click', function(){
    paused = !paused;
    this.textContent = paused ? 'Resume' : 'Pause';
  });
  document.getElementById('spawnBurst').addEventListener('click', function(){
    triggerBurst(rand(100,W-100), rand(100,H-100), true);
  });

  // responsive resize
  window.addEventListener('resize', ()=> {
    W = innerWidth; H = innerHeight;
    canvas.width = W * DPR; canvas.height = H * DPR;
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.scale(DPR, DPR);
  });

  // start
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
